


	Graph consists of either:

		SmerMap (indexing, optimized for adding nodes)
		SmerArray (routing)

	SmerMap
		16384 slices (2^14) - balanced using prefix-mixing

		Node split into 7bp prefix and lower 16bp

		Hash calculated based on the lower 16bp
			Lower part of hash determined location in slice
			Upper part of hash mixed with 7bp prefix determines slice


	SmerArray
		16384 slices (2^14) - 1:1 with SmerMap slices

		Each slice contains queue of inbound requests from other slices


	Indexing Parallel Task:

		Parsing Thread (master):
			Parses reads into SwqBuffers
			Submits to ParallelTask

		Ingress Thread:
			Pack Sequence
			Determine possible smers
			Check which already exist in SmerMap
			Insert extra if insufficent


	Building Parallel Task:

		Parsing Thread (master):
			Parses reads into SwqBuffers
			Submits to ParallelTask

		Ingress Thread:
			Pack Sequence
			Determine possible smers
			Prefilter smers with Bloom
			Determine index of smers from SmerArtray
			Determine first smer per read
			Queue first-smer task

		-- or --

		Ingress Thread:
			Pack Sequence
			Determine possible smers
			Queue smer-check tasks (per slice)

		Intermediate 1: (per slice)
			Check smers

		Intermediate 2:
			Determine first smer per read
			Queue first-smer task




	Handling Sequence Names and Quality Scores:

		Idea: Link names/qualities to first smer in sequence


		Problem 1:
			Position in first smer is potentially ambiguous until fully inserted

		Option 1A:
			Store label in last smer


		Problem 2:
			Long sequences need more frequent labels to be efficiently retrieved

		Option 2A:
			Label sequence intermittently






	Profiles:

		export CPUPROFILE=gperf.out
		pprof LOGAN-Graph-Native/bin/LOGAN gperf.out
		top20



	Performance target: 100GB data / 1GB genome -> 1 hour (on cessna - 16 cores)
			1 billion reads per hr
			~16M reads per minute
			~3.6s per million reads

			29,493,880 reads in 32.936886


	Dataset Profiles:


		Ecoli-1: Reads: 7248696 Smers: 1810392 (single threaded)

		 11.212197s using 8 threads (desktop):

		Original: (size > 40bp, 7143305 reads used, 1796025 smers)
			1 thread - 488.2s	4 threads - 305.7s

Total: 4724 samples
     739  15.6%  15.6%      753  15.9% scanForSmer_HS (inline)
     495  10.5%  26.1%      611  12.9% assignSmersToIntermediates
     469   9.9%  36.0%      469   9.9% testBloom
     364   7.7%  43.8%      364   7.7% siitFindSmer
     344   7.3%  51.0%      344   7.3% readBufferedFastqLine (inline)
     319   6.8%  57.8%      344   7.3% calculatePossibleSmersComp
     270   5.7%  63.5%     1294  27.4% scanForSmerLookups
     220   4.7%  68.2%      227   4.8% skipBufferedFastqLine (inline)
     181   3.8%  72.0%      182   3.9% assignIntermediatesToEntryLookups
     166   3.5%  75.5%      635  13.4% saFindSmerEntry
     134   2.8%  78.3%      140   3.0% calculatePossibleSmers
     129   2.7%  81.1%      892  18.9% smFindIndexesOfExistingSmers
     127   2.7%  83.8%      135   2.9% allocEntryLookupBlock (inline)
      94   2.0%  85.8%       94   2.0% __GI_madvise
      91   1.9%  87.7%       91   1.9% packSequence
      58   1.2%  88.9%       58   1.2% __memmove_ssse3_back
      57   1.2%  90.1%       61   1.3% hashForSmer
      51   1.1%  91.2%       51   1.1% __read_nocancel
      46   1.0%  92.2%     1138  24.1% addPathSmers
      44   0.9%  93.1%       44   0.9% smGetSmerCount_S (inline)




		Ecoli-2: Reads: 218470592 Smers: 5717584

		245.432265s using 16 threads (cessna)

Total: 208191 samples
   25954  12.5%  12.5%    26892  12.9% smFindIndexesOfExistingSmers
   20411   9.8%  22.3%    23641  11.4% parseAndProcess
   20345   9.8%  32.0%    20345   9.8% siitFindSmer
   19939   9.6%  41.6%    29925  14.4% assignSmersToIntermediates
   19931   9.6%  51.2%    19931   9.6% testBloom
   18412   8.8%  60.0%    18735   9.0% calculatePossibleSmersComp
   13816   6.6%  66.7%    60767  29.2% scanForSmerLookups
   10607   5.1%  71.8%    10609   5.1% calculatePossibleSmers
   10337   5.0%  76.7%    71946  34.6% trDoIngress
   10159   4.9%  81.6%    10195   4.9% assignIntermediatesToEntryLookups
    7612   3.7%  85.3%     7612   3.7% memcpy
    6675   3.2%  88.5%    26606  12.8% saFindSmerEntry
    5394   2.6%  91.1%     5394   2.6% madvise
    4227   2.0%  93.1%     4227   2.0% packSequence
    2939   1.4%  94.5%    41914  20.1% addPathSmers
    2341   1.1%  95.6%     2547   1.2% hashForSmer
    2323   1.1%  96.7%     2327   1.1% __read_nocancel
    1419   0.7%  97.4%     1419   0.7% __memset_sse2
    1083   0.5%  98.0%     1088   0.5% sliceForSmer
     801   0.4%  98.3%      801   0.4% __strchr_sse42





		Arabi-1: Reads: 29493880 Smers: 7969993 (single threaded)

		34.022125s using 16 threads (cessna)

Total: 29311 samples
    5373  18.3%  18.3%     5595  19.1% smFindIndexesOfExistingSmers
    2983  10.2%  28.5%     2983  10.2% siitFindSmer
    2754   9.4%  37.9%     3193  10.9% parseAndProcess
    2448   8.4%  46.3%     2448   8.4% testBloom
    2357   8.0%  54.3%     3527  12.0% assignSmersToIntermediates
    2096   7.2%  61.4%     2142   7.3% calculatePossibleSmersComp
    1803   6.2%  67.6%     7953  27.1% scanForSmerLookups
    1513   5.2%  72.8%     8869  30.3% trDoIngress
    1264   4.3%  77.1%     1295   4.4% assignIntermediatesToEntryLookups
    1167   4.0%  81.1%     1168   4.0% calculatePossibleSmers
     921   3.1%  84.2%      921   3.1% memcpy
     719   2.5%  86.7%     3167  10.8% saFindSmerEntry
     668   2.3%  88.9%      668   2.3% madvise
     527   1.8%  90.7%      527   1.8% packSequence
     463   1.6%  92.3%     7502  25.6% addPathSmers
     361   1.2%  93.5%      372   1.3% hashForSmer
     321   1.1%  94.6%      321   1.1% __read_nocancel
     308   1.1%  95.7%      308   1.1% __lll_unlock_wake
     215   0.7%  96.4%      215   0.7% __memset_sse2
     212   0.7%  97.1%      212   0.7% __lll_lock_wait

 		44.976393s using 8 threads (desktop)

 Total: 21781 samples
    3309  15.2%  15.2%     3393  15.6% scanForSmer_HS (inline)
    2398  11.0%  26.2%     2398  11.0% siitFindSmer
    2326  10.7%  36.9%     3045  14.0% assignSmersToIntermediates
    1948   8.9%  45.8%     1948   8.9% testBloom
    1472   6.8%  52.6%     1474   6.8% readBufferedFastqLine (inline)
    1405   6.5%  59.0%     1499   6.9% calculatePossibleSmersComp
    1178   5.4%  64.4%     6141  28.2% scanForSmerLookups
    1028   4.7%  69.2%     1052   4.8% assignIntermediatesToEntryLookups
     819   3.8%  72.9%      837   3.8% skipBufferedFastqLine (inline)
     705   3.2%  76.2%      772   3.5% calculatePossibleSmers
     643   3.0%  79.1%     4097  18.8% smFindIndexesOfExistingSmers
     607   2.8%  81.9%     2555  11.7% saFindSmerEntry
     477   2.2%  84.1%      477   2.2% __memmove_ssse3_back
     439   2.0%  86.1%      480   2.2% allocEntryLookupBlock (inline)
     426   2.0%  88.1%      426   2.0% __GI_madvise
     400   1.8%  89.9%      400   1.8% packSequence
     301   1.4%  91.3%      301   1.4% __GI___read
     260   1.2%  92.5%      285   1.3% hashForSmer
     200   0.9%  93.4%     5346  24.5% addPathSmers
     147   0.7%  94.1%      147   0.7% __memset_sse2



		Pen-1: Reads: 450786851 reads Smers: 53888249

		Jellyfish 2.2: 1417.936s

		645.088589s using 16 threads (cessna)

Total: 755176 samples
  123527  16.4%  16.4%   123527  16.4% siitFindSmer
  110390  14.6%  31.0%   113904  15.1% smFindIndexesOfExistingSmers
   74017   9.8%  40.8%   124713  16.5% assignSmersToIntermediates
   67599   9.0%  49.7%    67599   9.0% testBloom
   63796   8.4%  58.2%    64871   8.6% calculatePossibleSmersComp
   55690   7.4%  65.6%    55690   7.4% memcpy
   40460   5.4%  70.9%    54055   7.2% assignIntermediatesToEntryLookups
   37304   4.9%  75.8%    44413   5.9% parseAndProcess
   36354   4.8%  80.7%   247992  32.8% scanForSmerLookups
   29178   3.9%  84.5%    29188   3.9% calculatePossibleSmers
   26288   3.5%  88.0%   279159  37.0% trDoIngress
   20512   2.7%  90.7%    88111  11.7% saFindSmerEntry
   14364   1.9%  92.6%    14364   1.9% madvise
   14001   1.9%  94.5%    14001   1.9% packSequence
    9992   1.3%  95.8%   157000  20.8% addPathSmers
    7919   1.0%  96.9%     8652   1.1% hashForSmer
    4977   0.7%  97.5%     4982   0.7% __read_nocancel
    3839   0.5%  98.0%     3852   0.5% sliceForSmer
    3654   0.5%  98.5%     3654   0.5% __memset_sse2
    2065   0.3%  98.8%     2135   0.3% smConsiderResize


		1519.698321s using 8 threads (desktop)

Total: 962878 samples
  118125  12.3%  12.3%   138564  14.4% assignReversedInboundDispatchesToSlices (inline)
  109007  11.3%  23.6%   115401  12.0% extractIndexedSmerDataFromLookupPercolates (inline)
  108088  11.2%  34.8%   108103  11.2% siitFindSmer
   85924   8.9%  43.7%    85924   8.9% scanForSmer_HS.isra.1
   71981   7.5%  51.2%    99350  10.3% assignSmersToLookupPercolates (inline)
   56390   5.9%  57.1%    56390   5.9% testBloom
   32914   3.4%  60.5%    37572   3.9% assignPercolatesToEntryLookups (inline)
   31232   3.2%  63.7%    35020   3.6% calculatePossibleSmersComp
   30662   3.2%  66.9%    30662   3.2% __memmove_ssse3_back
   29344   3.0%  70.0%    29395   3.1% extractLookupPercolatesFromEntryLookups
   28990   3.0%  73.0%    37321   3.9% assignToDispatchArrayEntry (inline)
   28847   3.0%  76.0%    28987   3.0% readBufferedFastqLine (inline)
   25661   2.7%  78.6%    25735   2.7% assignReadDataToDispatchIntermediate (inline)
   25467   2.6%  81.3%   210242  21.8% scanForSmerLookupsForSlices
   24884   2.6%  83.9%    62207   6.5% processSlicesForGroup (inline)
   18599   1.9%  85.8%    20247   2.1% calculatePossibleSmers
   16926   1.8%  87.6%    73316   7.6% saFindSmerEntry
   13390   1.4%  88.9%    14575   1.5% hashForSmer
   11552   1.2%  90.1%    99979  10.4% smFindIndexesOfExistingSmers
    9234   1.0%  91.1%     9234   1.0% packSequence




Updated Profiles:

	Ecoli-1:


	Total: 9270 samples
     867   9.4%   9.4%      867   9.4% scanForSmer_HS.isra.1
     853   9.2%  18.6%     1048  11.3% indexDispatchesForSlice (inline)
     770   8.3%  26.9%     1112  12.0% processReadsForSmer
     742   8.0%  34.9%      832   9.0% assignReversedInboundDispatchesToSlices (inline)
     555   6.0%  40.9%      616   6.6% extractIndexedSmerDataFromLookupPercolates (inline)
     410   4.4%  45.3%      410   4.4% testBloom
     376   4.1%  49.3%      479   5.2% assignSmersToLookupPercolates (inline)
     372   4.0%  53.3%      420   4.5% assignToDispatchArrayEntry
     355   3.8%  57.2%      355   3.8% siitFindSmer
     323   3.5%  60.7%     2491  26.9% processGroupSlices (inline)
     286   3.1%  63.7%      286   3.1% extractLookupPercolatesFromEntryLookups
     270   2.9%  66.7%      679   7.3% gatherGroupOutbound (inline)
     239   2.6%  69.2%      266   2.9% calculatePossibleSmers
     214   2.3%  71.5%      214   2.3% assignPercolatesToEntryLookups (inline)
     186   2.0%  73.5%     1114  12.0% scanForSmerLookupsForSlices
     151   1.6%  75.2%      151   1.6% skipBufferedFastqLine (inline)
     149   1.6%  76.8%      559   6.0% saFindSmerEntry
     144   1.6%  78.3%      158   1.7% calculatePossibleSmersAndCompSmers
     130   1.4%  79.7%      130   1.4% readBufferedFastqLine (inline)
     129   1.4%  81.1%      135   1.5% dAlloc

	Ecoli-2:

   81650  13.9%  13.9%    94561  16.0% indexDispatchesForSlice (inline)
   73623  12.5%  26.3%    79955  13.6% assignReversedInboundDispatchesToSlices (inline)
   67831  11.5%  37.9%    95898  16.3% processReadsForSmer
   45742   7.8%  45.6%    50298   8.5% assignToDispatchArrayEntry
   35147   6.0%  51.6%    84997  14.4% gatherGroupOutbound (inline)
   28408   4.8%  56.4%   219490  37.2% processGroupSlices (inline)
   20948   3.6%  59.9%    23003   3.9% extractIndexedSmerDataFromLookupPercolates (inline)
   19594   3.3%  63.3%    19594   3.3% scanForSmer_HS.isra.1
   19054   3.2%  66.5%    19054   3.2% siitFindSmer
   15673   2.7%  69.2%    15677   2.7% testBloom
   13327   2.3%  71.4%    18262   3.1% assignSmersToLookupPercolates (inline)
   13296   2.3%  73.7%    13296   2.3% readBufferedFastqLine (inline)
   10755   1.8%  75.5%    11402   1.9% dAlloc
   10752   1.8%  77.3%    10758   1.8% __read_nocancel
   10631   1.8%  79.1%    11988   2.0% calculatePossibleSmers
   10143   1.7%  80.9%    10143   1.7% skipBufferedFastqLine (inline)
    7893   1.3%  82.2%     7893   1.3% assignReadDataToDispatchIntermediate
    6849   1.2%  83.4%     6849   1.2% __memset_avx2
    6475   1.1%  84.5%    48870   8.3% scanForSmerLookupsForSlices
    6411   1.1%  85.5%     6415   1.1% extractLookupPercolatesFromEntryLookups




	Arabi-1:

    8162  12.0%  12.0%    26246  38.4% processGroupSlices (inline)
    7618  11.2%  23.1%     8331  12.2% assignReversedInboundDispatchesToSlices (inline)
    7214  10.6%  33.7%    10069  14.8% indexDispatchesForSlice (inline)
    6266   9.2%  42.9%     7873  11.5% processReadsForSmer
    4233   6.2%  49.1%     4233   6.2% scanForSmer_HS.isra.1
    4051   5.9%  55.0%     4497   6.6% assignToDispatchArrayEntry
    2835   4.2%  59.2%     3161   4.6% extractIndexedSmerDataFromLookupPercolates (inline)
    2635   3.9%  63.0%     7045  10.3% gatherGroupOutbound (inline)
    2392   3.5%  66.5%     2392   3.5% __memset_avx2
    2254   3.3%  69.8%     2254   3.3% siitFindSmer
    1875   2.7%  72.6%     2676   3.9% assignSmersToLookupPercolates (inline)
    1651   2.4%  75.0%     1651   2.4% testBloom
    1282   1.9%  76.9%     1286   1.9% extractLookupPercolatesFromEntryLookups
    1161   1.7%  78.6%     1173   1.7% assignPercolatesToEntryLookups (inline)
    1122   1.6%  80.2%     1247   1.8% calculatePossibleSmers
     870   1.3%  81.5%      870   1.3% assignReadDataToDispatchIntermediate
     785   1.1%  82.6%      861   1.3% calculatePossibleSmersAndCompSmers
     717   1.1%  83.7%     5282   7.7% scanForSmerLookupsForSlices
     690   1.0%  84.7%      848   1.2% dAlloc
     670   1.0%  85.7%      670   1.0% __memmove_avx_unaligned




Pen-3 dataset (8 threads)

LOGAN INFO src/io/fastqParser.c(503) 71550.418970: Used 450338551 450338551
LOGAN INFO cliSrc/main.c(184) 71550.419041: Routing: Parsed 450338551 reads from data/Pen-3_Q20.fq
LOGAN INFO src/task/task.c(76) 71623.132304: Master: Done Shutdown
LOGAN INFO src/graph/graph.c(54) 71623.138983: Freeing Graph





Memory Usage:

valgrind --tool=massif --pages-as-heap=yes --massif-out-file=massif.out ./LOGAN-Graph-Native/bin/LOGAN data/Ecoli-1_Q20.fq 1 1
grep mem_heap_B massif.out | sed -e 's/mem_heap_B=\(.*\)/\1/' | sort -g | tail -n 1

/usr/bin/time -v ./LOGAN-Graph-Native/bin/LOGAN data/Ecoli-1_Q20.fq 1 1



Leak detection:

valgrind --leak-check=full --show-reachable=yes ./LOGAN-Graph-Native/bin/LOGAN data/Ecoli-1_Q20.fq 1 1




Intel stuff:

Download: ftp://software.rz.rwth-aachen.de/intel_2015_Gazsfe3hn2

export INTEL_LICENSE_FILE="50017@license2.rz.rwth-aachen.de"
/opt/intel/vtune_amplifier_xe/amplxe-vars.sh
export TMPDIR=/home/tony/intel/tmp
/opt/intel/vtune_amplifier_xe/bin64/amplxe-gui



/opt/intel/vtune_amplifier_xe/bin64/amplxe-cl -collect general-exploration -knob dram-bandwidth-limits=true -app-working-dir=/home/tony/Projects/PAGAN/LOGAN -result-dir=/home/tony/intel/amplxe/projects/LOGAN-Ecoli-2/cli001 -target-duration-type=long -duration=4000 /home/tony/Projects/PAGAN/LOGAN/LOGAN-Graph-Native/bin/LOGAN data/Ecoli-2_Q20.fq 1 8 8 




	Pack Kmers

A	0x41	65		0100 0001
C	0x43	67		0100 0011
G	0x47	71		0100 0111
T	0x54	84		0101 0100

00 00
01 00
11 01
10 01





	Calculate Possible Kmers:



	Pack -> Smer


	Smers are represented in big endian format (first base 'higher') - thus numerical packed sorting matches base alphabetical sorting


	Rmer:             -- -- -- --  -- -- -- --  23 22 21 20  19 18 17 16  15 14 13 12  11 10 09 08  07 06 05 04  03 02 01 00

	Fmer=bswap64(Rmer)

	Fmer:             00 01 02 03  04 05 06 07  08 09 10 11  12 13 14 15  16 17 18 19  20 21 22 23  -- -- -- --  -- -- -- --

	Rmer = Rmer << 2bp
	Fmer = Fmer >> 8bp


	Fmer1:            00 01 02 03  04 05 06 07  08 09 10 11  12 13 14 15  16 17 18 19  20 21 22 23

	FmerA: (>>1bp)       00 01 02  03 04 05 06  07 08 09 10  11 12 13 14  15 16 17 18  19 20 21 22
	FmerB:               01 02 03  04 05 06 07  08 09 10 11  12 13 14 15  16 17 18 19  20 21 22 23

	Fmer2:  01 02 03  04 05 06 07  08 09 10 11  12 13 14 15  16 17 18 19  20 21 22 23  24*25*26*27*

	FmerC: (>>3bp)       02 03 04  05 06 07 08  09 10 11 12  13 14 15 16  17 18 19 20  21 22 23 24*
	FmerD: (>>2bp)       03 04 05  06 07 08 09  10 11 12 13  14 15 16 17  18 19 20 21  22 23 24*25*

	FmerA2: (>>1bp)      04 04 06  07 08 09 10  11 12 13 14  15 16 17 18  19 20 21 22  23 24*25*26*
	FmerB2:              05 06 07  08 09 10 11  12 13 14 15  16 17 18 19  20 21 22 23  24*25*26*27*


	Rmer1:     23 22  21 20 19 18  17 16 15 14  13 12 11 10  09 08 07 06  05 04 03 02  01 00 -- --

	RmerA: (>>2bp)       22 21 20  19 18 17 16  15 14 13 12  11 10 09 08  07 06 05 04  03 02 01 00
	RmerB: (>>3bp)       23 22 21  20 19 18 17  16 15 14 13  12 11 10 09  08 07 06 05  04 03 02 01

	Rmer2:    27*26*  25*24*23 22  21 20 19 18  17 16 15 14  13 12 11 10  09 08 07 06  05 04 03 02

	RmerC:               24*23 22  21 20 19 18  17 16 15 14  13 12 11 10  09 08 07 06  05 04 03 02
	RmerD: (>>1bp)       25*24*23  22 21 20 19  18 17 16 15  14 13 12 11  10 09 08 07  06 05 04 03

	RmerA2: (>>2bp)      26*25*24* 23 22 21 20  19 18 17 16  15 14 13 12  11 10 09 08  07 06 05 04
	RmerB2: (>>3bp)      27*26*25* 24 23 22 21  20 19 18 17  16 15 14 13  12 11 10 09  08 07 06 05




	Cache Structure:
		32K / 256K / 2-2.5M per core (sandy/ivy/haswell)

		Pen D dataset:
			Single: 50M smers * 4 bytes -> 200MB
			Mid: 384K smers * 4 bytes -> 1.5MB
			Slice: 3K smers * 4 bytes -> 12KB

		Notional dataset (100x pen D):
			Single: 5000M smers * 4 bytes -> 20GB
			Mid: 38.5M smers * 4 bytes -> 150MB
			Slice: 300K smers * 4 bytes -> 1.2MB

	Bloom filters: Option to speed up SmerArray queries
		Expect true positive rate 10-20%
		4-8 bits per entry for 2-15% false positive rate

		Pen D dataset:
			Single: 50M smers * 4bits -> 25MB
			Mid: 384K smers * 4 bits -> 192KB
			Slice: 3K smers * 4 bits -> 1.5KB

		Notional dataset (100x pen D):
			Single: 5000M smers * 4 bits -> 2500MB
			Mid: 38.5M smers * 4 bits -> 19.2MB
			Slice: 300K smers * 4 bits -> 150KB

		Consider blocked bloom filters: All queries for a given key hit the same 64 byte region
			Pattern filters also possible (SIMD advantages)

	Read batching for lookup:
		1000 reads per batch -> ~80 kmers per read -> 80K kmers per batch (~5 per slice). 640KB kmer in flight
		10000 reads per batch -> ~80 kmers per read -> 800K kmers per batch (~50 per slice). 6.4MB kmer in flight

		Multiple batches:
		10 batches, 10K per batch -> ~80 kmers per read -> 8M kmers per batch (~500 per slice) 64MB kmer in flight
		20 batches, 10K per batch -> ~80 kmers per read -> 16M kmers per batch (~1000 per slice) 128MB kmer in flight
		100 batches, 10K per batch -> ~80 kmers per read -> 80M kmers per batch (~5000 per slice) 640MB kmer in flight

	Read batching for routing:
		1000 reads per batch -> ~8 kmers per read -> 8K kmers per batch (~0.5 per slice).
		10000 reads per batch -> ~8 kmers per read -> 80K kmers per batch (~5 per slice).

	Sub-bloom filters:
		Idea: Build one or more 'read batch specific' bloom filters from the smers within a read batch
		Improves cache behaviour




Tail/Route tables:

	Issues:
		Batching:
			Common Smers should delay reads until a group is accumulated
			Rare Smers should process reads ASAP

		Tail/Route data grows with each Smer update

		Low memory overhead (<10% or less)
			Additional data for tracking
			Internal fragmentation

		Low CPU overhead (copy-based compaction etc).



Each slice contains 500-5000 Smers:

	Need to group by Smer, orientation and upstream edge (or smer+length), but preserve order within these





Building Tails Routes:

Equivalent RC reads share prefix,smer and suffix


Canonical Reads map as: rc(-1) -> prefix, (0) -> smer, (1) -> suffix
RevComp Reads map as:   rc(-1) -> suffix, rc(0) -> smer, (1) -> prefix

Smers are stored with last base as LSBs
Tails are stored with last base as LSBs, length as top 16 bits

Prefix is stored in reverse complement (vs smer), Suffix is stored in canonical orientation



Canonical Orientation (assuming forward mer arrays):

	Smer = Fmer[0]
	Prefix = Rmer[-1]
	Suffix = Fmer[+1]

RevComp Orientation:

	Smer = Rmer[0]
	Prefix = Fmer[+1]
	Suffix = Rmer[-1]





Node/Edge Positions:

Node Positions can be numbered as follows:

Option 1: (Old) Forward routes, then reverse routes
Option 2: (Current) Forward and reverse routes separately

Edge Positions originating from forward/reverse routes must be distinguishable

Option 1: (Old): Count route in forward table, then routes in reverse table
	Edge-Node transition depends on direction through node (arriving on a suffix reverses route table ordering)
	Edge-Edge transitions maintain position

Option 2: (Current): Store routing table flag also in edge context
	Edge-Node transition maintains forward/reverse routing table flag in edge
	Edge-Edge transition needs to set routing table flag depending on orientation of target smer




Transitions:

Canonical->Canonical: Original sequence direction
	Suffix->Prefix. Forward Routes -> Forward Routes

Canonical<-Canonical: Complementary sequence direction
	Prefix->Suffix. Forward Routes -> Forward Routes


Canonical->Complementary: Original sequence direction,
	Suffix->Suffix. Forward Routes -> Reverse Routes

Canonical<-Complementary: Complementary sequence direction
	Suffix->Suffix: Reverse Routes -> Forward Routes


Complementary->Canonical: Original sequence direction,
	Prefix->Prefix. Reverse Routes -> Forward Routes

Complementary<-Canonical: Complementary sequence direction
	Prefix->Prefix: Forward Routes -> Reverse Routes


Complementary->Complementary: Original sequence direction,
	Prefix->Suffix. Reverse Routes -> Reverse Routes

Complementary<-Complementary: Complementary sequence direction
	Suffix->Prefix: Reverse Routes -> Reverse Routes





------

Canonical<-Canonical: Complementary sequence direction
	Prefix->Suffix. Forward Routes -> Forward Routes

Complementary<-Canonical: Complementary sequence direction
	Prefix->Prefix: Forward Routes -> Reverse Routes



Complementary->Canonical: Original sequence direction,
	Prefix->Prefix. Reverse Routes -> Forward Routes

Complementary->Complementary: Original sequence direction,
	Prefix->Suffix. Reverse Routes -> Reverse Routes




High priority Tasks:
	Merge-insert for multiple route updates (currently rescan per read)

	Non-linear form for busy smers (some kind of tree, first division by upstream, later by offset range)

	Non-packed form for busy smers (unpacked cache)
		
	Block-shared & generational garbage collection 


Low Priority Tasks:

	Better tail representation: Implicit short sequences, tree-form
	
	Better route representation: Move to Front encoding, variable bit width









Merge Rules:

	Scanning patches for 'compatible patch groups':

	Groups must share prefix

	Routes can be considered as:
		Narrow: 1 option, positions range (x:x)
		Wide: >1 option, positions range (x:>x)

	Narrow routes are limited to precisely one position within their upstream routes
		These have a unique upstream sequences
		They must 'touch' existing routes within the list (no gaps)
		Each additional narrow route must be inserted into the existing position-ordered list

	Wide routes can be placed either side of, or within, existing routes
		These share their upstream sequences
		They must 'fully cover' existing routes within the list (same start, end increased by 1)
		Routes can be sorted by prefix

	Individual narrow routes can become wide if appropriate patches occur



Merge Tree: 3 levels, in a tree-like structure

	Root: Reference to RoutePatchMergePositionOrderedReadtree

	1st Level Branch: RoutePatchMergePositionOrderedReadTree: 'Ordered' lists of readsets.
		Required to represent the fixed relative ordering of reads which have distinct upstream
		The members of this list have known relative order to each other, but not internally within each set.

	2nd Level Branch: RoutePatchMergeWideReadset: A set of 'Compatible' reads with no defined relative order.
		Required to represent the flexible ordering of reads which have identical upstream sequences (rare case)
		Implemented using a linked-list of 'compatible' leaves, via 'firstRoutePatch'
		Entire set shares a min/max Edge offset (for efficiency, relative to parent)

	Leaves: RoutePatch, linked via 'next'



Routes pre-state:			->							Or

1	Unknown						1	Unknown					1	Unknown
2	Unknown						2	Unknown					2	Unknown
3		OldA (3,3)				3		OldA (3,3)			3		OldA (3,3)
4		OldB (4,4)				4		OldB (4,4)			4		OldB (4,4)
5		OldC/Unknown (5,6)		5		OldC (5,6)			5		Unknown (5,6)
6		OldC/Unknown (5,6)		6		Unknown (5,6)		6		Unknown (5,6)
7		OldD (7,7)				7		OldD (7,7)			7		OldD (7,7)
8	Unknown						8	Unknown					8	Unknown
9 		OldE (9,9)				9 		OldE (9,9)			9 		OldE (9,9)
10	Unknown						10	Unknown					10	Unknown
11	Unknown...					11	Unknown...				11	Unknown...




ScenarioGroup 1: 'Isolated Before': New PositionOrderedReadTree, New MergeWideReadset (NewMax<OldMinA)

Routes N.1: Narrow' case (2,2):(NewMin=NewMax)

1	Unknown
2   New (2,2)					<--
3	Unknown
4	OldA (3+1,3+1)
5	OldB (4+1,4+1)
6	OldC/Unknown (5+1,6+1)
7	OldC/Unknown (5+1,6+1)
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...

Routes W.1: 'Wide' case (1,2): (NewMin<NewMax)

1	New/Unknown (1,2)			<--
2   New/Unknown (1,2)			<--
3   Unknown
4	OldA (3+1,3+1)
5	OldB (4+1,4+1)
6	OldC/Unknown (5+1,6+1)
7	OldC/Unknown (5+1,6+1)
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...


ScenarioGroup 2: 'Linked Before/Other': (NewMax=OldMinX)

Routes N.2A: 'Narrow' case (3,3): New MergeWideReadset, insert into existing PositionOrderedReadTree (NewMin=NewMax)

1	Unknown
2   Unknown
3   New (3,3)					<--
4	OldA (3+1,3+1)
5	OldB (4+1,4+1)
6	OldC/Unknown (5+1,6+1)
7	OldC/Unknown (5+1,6+1)
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...

Routes N.2B: 'Narrow' case (4,4): New MergeWideReadset, insert into existing PositionOrderedReadTree (NewMin=NewMax, NewMin=OldMinX)

1	Unknown
2	Unknown
3	OldA (3,3)
4   New (4,4)					<--
5	OldB (4+1,4+1)
6	OldC/Unknown (5+1,6+1)
7	OldC/Unknown (5+1,6+1)
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...

Routes N.2C: 'Narrow' case (6,6): Invalid narrow insert within existing wide (NewMin=NewMax, NewMin>OldMinX, NewMax<=OldMaxX)

1	Unknown
2	Unknown
3		OldA (3,3)
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6) 		<-x
7		OldD (7,7)
8	Unknown
9 		OldE (9,9)
10	Unknown
11	Unknown...


Routes W.2A: 'Wide' case (2,3): Insert into exist MergeWideReadset (NewMin<NewMax)

1	Unknown
2   New/Unknown (2,3)			<--
3   New/Unknown (2,3)			<--
4   OldA (3+1,3+1)
5	OldB (4+1,4+1)
6	OldC/Unknown (5+1,6+1)
7	OldC/Unknown (5+1,6+1)
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...

Routes W.2B: 'Wide' case (4,5): Insert into MergeWideReadset (NewMin<NewMax, NewMin=OldMinX, NewMax=OldMaxX+1)

1	Unknown
2	Unknown
3	OldA (3,3)
4   New/OldB (4,5)				<--
5   New/OldB (4,5)				<--
6	OldB (4+1,4+1)
6	OldC/Unknown (5+1,6+1)
7	OldC/Unknown (5+1,6+1)
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...

Routes W.2C: 'Wide' case (5,7): Insert into MergeWideReadset (NewMin<NewMax, NewMin=OldMinX, NewMax=OldMaxX+1)

1	Unknown
2	Unknown
3	OldA (3,3)
4	OldB (4,4)
5	New/OldC/Unknown (5,6+1)	<--
6	New/OldC/Unknown (5,6+1)	<--
7	New/OldC/Unknown (5,6+1)	<--
8	OldD (7+1,7+1)
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...

Routes W.2D: 'Wide' case (2,4): Invalid wide spanning unknown&known (NewMin<NewMax, NewMin<OldMinX, NewMax>OldMin)

1	Unknown
2	Unknown						<-x
3		OldA (3,3)				<-x
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
8	Unknown
9 		OldE (9,9)
10	Unknown
11	Unknown...

Routes W.2E: 'Wide' case (3,5): Invalid wide spanning multiple (NewMin<NewMax, NewMin=OldMinX, NewMax>OldMax+1)

1	Unknown
2	Unknown
3		OldA (3,3)				<-x
4		OldB (4,4)				<-x
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
8	Unknown
9 		OldE (9,9)
10	Unknown
11	Unknown...




ScenarioGroup 3: 'Linked After': (NewMin=OldMaxX+1, OldX is last in PositionOrderedReadTree)

Routes N.3: 'Narrow' case (8,8): New MergeWideReadset, append to existing PositionOrderedReadTree  (NewMin=NewMax)

1	Unknown
2	Unknown
3		OldA (3,3)
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
8		New (8,8)				<--
9	Unknown
10 		OldE (9+1,9+1)
11	Unknown
12	Unknown...


Routes W.3A: 'Wide' case (10,11): New MergeWideReadset, append to existing PositionOrderedReadTree (NewMin<NewMax, Last PositionOrderedReadTree)

1	Unknown
2	Unknown
3		OldA (3,3)
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
8	Unknown
9 		OldE (9,9)
11		New/Unknown (10,11)		<--
11		New/Unknown (10,11)		<--
12	Unknown...


Routes W.3B: 'Wide' case (7,8): Invalid due to (OldYMin=NewMax), prefer insert to next PositionOrderedReadTree (W.2) (NewMin<NewMax, not Last PositionOrderedReadTree)

1	Unknown
2	Unknown
3		OldA (3,3)
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
	--------
8		New/Unknown (8,9)		<--
9		New/Unknown (8,9)		<--
10 		OldE (9+1,+1)
11	Unknown
11	Unknown...




ScenarioGroup 4: 'Isolated After': New MergeWideReadset, append to existing PositionOrderedReadTree (NewMin>OldMaxX+1, OldX is last in PositionOrderedReadTree)

Routes N.5: Narrow' case (11,11):(NewMin=NewMax)

1	Unknown
2	Unknown
3		OldA (3,3)
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
8	Unknown
9 		OldE (9,9)
10	Unknown
11		New (11,11)				<--
12	Unknown...


Routes W.5: 'Wide' case (1,2): (NewMin<NewMax)

1	Unknown
2	Unknown
3		OldA (3,3)
4		OldB (4,4)
5		OldC/Unknown (5,6)
6		OldC/Unknown (5,6)
7		OldD (7,7)
8	Unknown
9 		OldE (9,9)
10	Unknown
11		New/Unknown (11,12)		<--
12		New/Unknown (11,12)		<--
13	Unknown...




Merge Tree Overlap concepts:

	Read positions are relative to the edge at the time they were added to the previous smer

	Read additions are conceptually 'insertions' into the merge tree, except when they occur after all previously added reads, in which case they are appends

	As such each new read occurring 'earlier' in the merge tree 'pushes' later reads 'down' (increments position) to compensate

	Each NewRead contains a position range where they must be inserted, represented using a minimum / maximum edge position (semi-open, so min<=pos<max)

	Assuming an existing read with position range: OldMin,OldMax, with OldMax>OldMin, and a new read with equivalents, NewMin,NewMax, with NewMax>NewMin:

	New before Old: If NewMax<=OldMin,




Merge Tree Building Algorithm:

	First read forms a branch at each level

	For additional reads:

	Check NewRead against each RoutePatchMergePositionOrderedReadTree:

	If NewRead.maximumEdgePosition <






Merge Flowchart:


// If end of existing routes, insert
// If past upstream tail, insert
// If 






Scratch space:

Inbound read (3,3)

Offset: 0
Existing: 1
Offset: 1
Existing: 1
Offset 2:
Existing: 1
Offset 3: <-- Insert here
Existing: 1
Offset 4:


Inbound read (3,4)

Offset: 0
Existing: 1
Offset: 1
Existing: 1
Offset 2:
Existing: 1
Offset 3:   <-- Insert here
Existing: 1 <-- Widen here
Offset 4:   <-- Insert here
Existing: 1
Offset 4:




